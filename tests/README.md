# Unit Testing WASM Functions

Given the current state of WebAssembly Text development tools (which is pretty minimal to be honest), the approach adopted here for unit testing individual WASM functions is somewhat cumbersome and less than ideal; however, it does provide a basic framework.

It would not be particularly good practice to take a private WASM function and temporarily give it an `export` definition, simply for the purpose of testing.
Instead, for each private function that needs to be unit tested, a corresponding public test function has been created that:

1. Calls the private WASM function passing in a known test value and trapping the return value
1. Calls a function imported from the host environment passing in:
   * An arbitrary test id for identifying which function is being tested
   * The function's test result
   * The expected result
1. The function in the host environment then determines the success or failure of the WASM unit test

***IMPORTANT***<br>
Once unit testing is complete, all the unit test WASM functions should be commented out as they serve no useful purpose in the production version of the binary.

This is certainly not a good way of approaching test-driven development; however, the reality is that writing code directly in WebAssembly Text is not really the mainstream use case.
Since almost all `.wasm` files are generated by compilers from source code written in a high-level language such as Rust (where there is already a powerful testing framework), it seems to me that giving the WAT developer some unit testing tools is something of a non-goal...

Nonetheless, if you want to develop code directly in WebAssembly Text, the following unit test approach (or something very like it) will be needed:

## Manual Workaround: An Example

In this example, we will create a unit test for one of the private WASM functions used by the SHA256 algorithm: `$choice`.

```wast
;; $choice = (e AND f) XOR (NOT(e) AND g)
;; Since WebAssembly has no bitwise NOT instruction, NOT must be implemented as i32.xor($val, -1)
(func $choice
      (param $e i32)
      (param $f i32)
      (param $g i32)
      (result i32)
  (i32.xor
    (i32.and (local.get $e) (local.get $f))
    (i32.and (i32.xor (local.get $e) (i32.const -1)) (local.get $g))
  )
)
```

Instead of temporarily making `$choice` public and testing it directly, create a specific public test function:

```wast
(func (export "should_return_choice")
  (call $check_result         ;; Function imported from host environment
    (i32.const 1)             ;; Test id
    (call $choice             ;; Call to private function returns some result
      (i32.const 0x510E527F)  ;; $e
      (i32.const 0x9B05688C)  ;; $f
      (i32.const 0x1F83D9AB)  ;; $g
    )
    (i32.const 0x1F85C98C)    ;; Expected result
  )
)
```

Where function `$check_result` has been imported from the host environment

```wast
(module
  (import "test" "checkResult"
    (func $check_result
          (param i32)  ;; Test id
          (param i32)  ;; Arg 1 - Got value
          (param i32)  ;; Arg 0 - Expected value
    )
  )

  ;; SNIP
)
```

Based on the value of the test id, the host environment function can then identify which WASM function is being tested and check the result appropriately.

```javascript
// Check the result returned by a WASM function test
const wasmTestCheckResult = (testId, gotI32, expectedI32) => {
  let fnName = ""

  switch (true) {
    case testId == 1:
      fnName = "$choice"

      if (gotI32 !== expectedI32) {
         console.log(`Success: ${fnName}`)
      } else {
         console.error(`Error: ${fnName} Got ${gotI32}, expected ${expectedI32}`)
      }

      break
  }
}
```

When the host environment instantiates the WASM module, a host environment object must be supplied that contains at least a reference to the above function.

```javascript
const hostEnv = {
  // SNIP - other stuff
  "test": {
    "checkResult": wasmTestCheckResult,
  }
  // SNIP - more stuff
}
```

Finally, create a unit test module in the host environment for running all the WASM unit tests

```javascript
// Async function to instantiate WASM module/instance
const startWasm =
  async pathToWasmFile => {
    let wasmMod = await WebAssembly.instantiate(
      new Uint8Array(fs.readFileSync(pathToWasmFile)),
      hostEnv,
    )

    return wasmMod.instance.exports
  }

// Run all the unit tests
startWasm(wasmFilePath)
  .then(wasmExports => {
    // SNIP
    wasmExports.should_return_choice()
  })
```

After testing has completed, the WASM unit test functions should be commented out.
